## 적용 가능성
#### 기존 클래스를 사용하고 싶지만 해당 인터페이스가 나머지 코드와 호환되지 않는 경우 어댑터 클래스를 사용합니다.

어댑터 패턴을 사용하면 코드와 레거시 클래스, 타사 클래스 또는 이상한 인터페이스가 있는 다른 클래스 간의 변환기 역할을 하는 중간 계층 클래스를 만들 수 있습니다.

#### 상위 클래스에 추가할 수 없는 몇 가지 공통 기능이 없는 여러 기존 하위 클래스를 재사용하려는 경우 패턴을 사용합니다.

각 하위 클래스를 확장하고 누락된 기능을 새 하위 클래스에 넣을 수 있습니다. 그러나 이 모든 새 클래스에 걸쳐 코드를 복제해야 하므로 중복코드의 위험이 매우 큽니다. 
<br/>
훨씬 더 우아한 솔루션은 누락된 기능을 어댑터 클래스에 넣는 것입니다. 그런 다음 어댑터 내부에 누락된 기능이 있는 개체를 래핑하여 필요한 기능을 동적으로 얻습니다. 이것이 작동하려면 대상 클래스에 공통 인터페이스가 있어야 하고 어댑터의 필드가 해당 인터페이스를 따라야 합니다. 이 접근 방식은 Decorator 패턴 과 매우 유사해 보입니다 .

## 구현 방법
1. 호환되지 않는 인터페이스가 있는 클래스가 두 개 이상 있는지 확인합니다.

- 변경할 수 없는 유용한 서비스 클래스(종종 타사, 레거시 또는 기존 종속성이 많음).
- 서비스 클래스를 사용하여 이점을 얻을 수 있는 하나 이상의 클라이언트 클래스.

2. 클라이언트 인터페이스를 선언하고 클라이언트가 서비스와 통신하는 방법을 설명합니다.

3. 어댑터 클래스를 만들고 클라이언트 인터페이스를 따르도록 합니다. 지금은 모든 방법을 비워 둡니다.

4. 서비스 개체에 대한 참조를 저장할 어댑터 클래스에 필드를 추가합니다. 일반적인 방법은 생성자를 통해 이 필드를 초기화하는 것이지만 때로는 메서드를 호출할 때 어댑터에 전달하는 것이 더 편리합니다.

5. 어댑터 클래스에서 클라이언트 인터페이스의 모든 메서드를 하나씩 구현합니다. 어댑터는 인터페이스 또는 데이터 형식 변환만 처리하면서 실제 작업의 대부분을 서비스 개체에 위임해야 합니다.

6. 클라이언트는 클라이언트 인터페이스를 통해 어댑터를 사용해야 합니다. 이렇게 하면 클라이언트 코드에 영향을 주지 않고 어댑터를 변경하거나 확장할 수 있습니다.

## 장점과 단점
✔ 단일 책임 원칙 . 프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있습니다.
<br/>
✔ 개방/폐쇄 원칙 . 클라이언트 인터페이스를 통해 어댑터와 함께 작동하는 한 기존 클라이언트 코드를 손상시키지 않고 새로운 유형의 어댑터를 프로그램에 도입할 수 있습니다.
<br/>
❌ 새로운 인터페이스와 클래스 세트를 도입해야 하기 때문에 코드의 전반적인 복잡성이 증가합니다. 때로는 코드의 나머지 부분과 일치하도록 서비스 클래스를 변경하는 것이 더 간단합니다.